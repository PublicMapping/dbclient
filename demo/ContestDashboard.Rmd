---
title: "Map Across America Dashboard"
author:
- name: Micah Altman
  url: https://micahaltman.com
  affiliation: MIT Libraries -- [Center for Research on Equitable and Open Scholarship](
    https://libraries.mit.edu/creos/)
  affiliation_url: https://libraries.mit.edu/creos/
  orcid_id: 0000-0001-7382-6960
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: 1
    #toc_float:
    #  collapsed: false
    #smooth_scroll: false
    number_section: yes
    highlight: zenburn
    code_folding: hide
    includes:
      in_header: header.html

runtime: shiny
params:
  refresh_data:
    value: no
    choices:
    - yes
    - no
  clean_data:
    value: no
    choices:
    - yes
    - no
  debug:
    value: no
    choices:
    - yes
    - no
  submission_gdrive_uri: https://docs.google.com/spreadsheets/d/1bfwyZ50OxBgSHwJIz9o-7HXj4g3rikRSwmCtbyjrlVA/
  submission_url_field: 4
  submission_desc_field: 9
  apikey: ""
  working_dir: contest_tmp
bibliography: dashboard.bib
resource_files:
- contest_tmp/checkpoint.RData
- dbclient.R
---

```{r setup, include=FALSE }
### Setup 

## Knit environment & parameters
library(knitr)
# options for this document
GLOBALS <- params
knitr::opts_chunk$set("message" = GLOBALS$debug)
knitr::opts_chunk$set("warning" = GLOBALS$debug)
knitr::opts_chunk$set("tidy" = FALSE) # already tidyed using stylr
knitr::opts_chunk$set(autodep=TRUE)

## Libraries
library("tidyverse")
library("readxl")
library("haven")
library("magrittr")
library("gt")
library("googledrive")
library("httr")
library("fs")
library("shiny")
library("DT")
#library("ggplotify")
#library("sf")
library("ggspatial")
library("bslib")
library("thematic")

## Directories setup
GLOBALS$plan_dir  <- fs::path(GLOBALS$working_dir,"plans")
GLOBALS$checkpoint  <- fs::path(GLOBALS$working_dir,"checkpoint",ext="RData")

if (params$clean_data) {
  unlink(GLOBALS$working_dir, recursive=TRUE)
  dir.create(GLOBALS$working_dir)
   dir.create(GLOBALS$plan_dir)
} 


```

```{css css-setup, echo=FALSE}
@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville&display=swap');
div.main-container {
  max-width: 1600px !important;
}
body {
  font-family: 'Libre Baskerville', serif;
}
img
{
    display:block; 
    float:none; 
    margin-left:auto;
    margin-right:auto;
    width:80%;
    text-align:center;
}
.caption
{
    display:block; 
    float:none; 
    margin-left:auto;
    margin-right:auto;
    width:80%;
    text-align:center;
}
aside {
    float: right;
    color: blue;
}


/* aside mod from tufte.css but remapped to aside element */

aside {
    float: right;
    clear: right;
    margin-right: -60%;
    width: 50%;
    margin-top: 0.3rem;
    margin-bottom: 0;
    font-size: 1.1rem;
    line-height: 1.3;
    vertical-align: baseline;
    position: relative;
}

/*fix for DT scrolling and header alignment*/
.dataTables_wrapper{ overflow-x: auto; clear:both; }

```

```{r, load-dbclient}
## Dblient routines
#TODO: Replace with library load when dbclient library is pushed to CRAN
try(silent=TRUE, {source("../R/dbclient.R")})
try(silent=TRUE, {source("./R/dbclient.R")})
try(silent=TRUE, {source("dbclient.R")})
.onLoad()
```

```{r, refresh }
### Refresh plan set 
refresh_checkpoint <- function(checkpoint=GLOBALS$checkpoint) {
  
  # Update id list
  tmpsubfile <- fs::path(params$working_dir,"submissions",ext="xlsx")
  googledrive::drive_deauth()
  googledrive::drive_download(
    googledrive::as_id(params$submission_gdrive_uri),
    path = tmpsubfile,
    overwrite = TRUE
  )
  tmpxl <- readxl::read_excel(tmpsubfile)
  contestPlans.tb <- tmpxl %>% select(GLOBALS$submission_url_field, GLOBALS$submission_desc_field) 
  names(contestPlans.tb) <- c("url","description")
  contestPlans.tb %<>% mutate( id = str_replace(url, ".*projects/(.*)$","\\1"))
  contestPlans.tb %<>% group_by(id) %>% slice_tail(n=1) %>% ungroup() # deduplicate repeat submission
  
  # Retrieve new plan files
  
  tmpmeta <- db2meta(contestPlans.tb$id,targetdir=GLOBALS$plan_dir)
  contestPlans.tb %<>% inner_join(tmpmeta,by=c("id"="plan_id")) # this drops plans that weren't retreiveable
  contestPlans.sflist <- db2sf(contestPlans.tb$id,targetdir=GLOBALS$plan_dir)
  
  # Update plan scores
  
  contestScores.df <- map_dfr(contestPlans.sflist, function(x)
    as.data.frame(x) %>% 
      ungroup() %>% 
      mutate(properties.contiguity = properties.contiguity=="contiguous") %>%
      filter(id>0) %>%
      summarize(across(starts_with("properties"), ~ mean(.x, na.rm = TRUE),  .names = "{.col}_mn"))
  )
  names(contestScores.df) <-  str_replace(names(contestScores.df),"properties.","")
  contestPlans.tb %<>% bind_cols(contestScores.df)
  contestPlans.tb %<>% bind_cols(tibble(map=contestPlans.sflist))
  
  if (params$apikey!="" & options()$dbclient.pscore.apikey =="") {
        options("dbclient.pscore.apikey"=apikey)
  }
  
  # add unassigned score -- detect incomplete districts
  
  unassigned.tb<-contestPlans.tb %>% rowwise() %>% transmute(head= map %>% as.data.frame() %>% slice_head(n=1)) %>%unpack(head)

unassigned_scores.tb <- unassigned.tb %>% rowwise() %>% transmute(
  unassigned_geography=(length(geometry[[1]])>0),
  unassigned_population= sum(c_across(starts_with("properties.demographics")) > 0 ,na.rm=TRUE)>0
           )

contestPlans.tb %<>% bind_cols(unassigned_scores.tb) 

# compute  maj-min district scores -- these are missing in score results
majmin.tb <- contestPlans.tb %>% 
  select("id","map") %>% rename(planid=id) %>%
  unnest(map) %>%
  select(planid,id,starts_with("properties.demographics")) %>%
  filter(id>0) %>% 
  rowwise() %>% 
  mutate(percent_white = properties.demographics.white / properties.demographics.population,
         is_maj_min_district = percent_white <.5)  %>%
  group_by(planid) %>% 
  summarize(majMin_n=sum(is_maj_min_district),numdists=n()) %>% 
  ungroup() %>%
  rename(id=planid)

contestPlans.tb %<>% left_join(majmin.tb) 

tmpsplits.tib<-map_dfr(contestPlans.tb$id, function(x) {
  tmpblocks.tb <- db2df(x,targetdir = GLOBALS$plan_dir)[[1]]
  tmpblocks.tb %>%
    mutate(county=str_sub(BLOCKID,3,5)) %>%
    group_by(county) %>% 
    summarize(splits=length(unique(DISTRICT))-1) %>%
    ungroup() %>%
    summarise(county_split_count = sum(splits>0), county_split_sum=sum(splits))
})

contestPlans.tb %<>% bind_cols(tmpsplits.tib) 


contestPlans.tb %<>% relocate(plan_name,url,unassigned_geography,unassigned_population,numdists,contiguity_mn,majMin_n,county_split_count,county_split_count)


# Add Planscores  
  if (options()$dbclient.pscore.apikey !="") {
      tmpplanscore.df  <- generate_planscore_df(contestPlans.tb$id, targetdir=GLOBALS$plan_dir)
      contestPlans.tb %<>% left_join(tmpplanscore.df,by=c("id"="id"))
      contestPlans.tb %<>% relocate(plan_name,url,unassigned_geography,unassigned_population,numdists,contiguity_mn,majMin_n,county_split_count,county_split_count,`Efficiency Gap`,`Partisan Bias`)

  }    
  
  # Cleanup  & checkpoint
  
  save(contestPlans.tb, file=checkpoint)
  
} 

if (GLOBALS$refresh_data) refresh_checkpoint()

```

```{r, load-checkpoint}
load(GLOBALS$checkpoint)
```

# Scores

```{r, explore-plans}
### Explore set of plans
contestPlans.tb %<>% 
  mutate(psView = str_replace( planscoreURI, 
      ".*/(.*)/index.json","https://planscore.campaignlegal.org/plan.html?\\1"),
        psView=paste("<a href='",psView,"' target='_ps'>",psView,"</a>",sep=""),
        dbView=paste("<a href='",url,"' target='_db'>",url,"</a>",sep="")) 

pscore.tb <- reactive(contestPlans.tb %>% select(-map, -districtScoreTable))

# Score table
thematic_shiny()
# TODO: Auto size height to avoid vertical scrolling
renderDT({
   pscore.tb() %>% 
  select(-file_src, -planscoreURI, -description) %>%
   relocate(plan_name, unassigned_geography, unassigned_population, numdists, contiguity_mn, majMin_n, county_split_count, county_split_sum, dbView, psView) %>%
  datatable(class = "cell-border stripe; hover",
            caption = "",
            editable=FALSE,
            escape=FALSE,
            selection=list(mode="single",selected=1),
            filter="top",  
            rownames=FALSE,
            extensions = list(
                      "ColReorder" = list(TRUE),
                      "Buttons" = NULL
                      ),
           options = list(
                dom = 'RrlBftpi',
                autoWidth=TRUE,
                #bAutoWidth=FALSE,
                pageLength=5,
                scrollX=FALSE,
                lengthMenu = list(c(5, 50, -1), c('5', '20', 'All')),
                buttons =
                  list(
                    'copy',
                    'print',
                    list(
                      extend = 'collection',
                      buttons = c('csv', 'excel', 'pdf'),
                      text = 'Download'
                    ),
                   I('colvis')
                  )
              )
    )  %>% 
 formatStyle(
    'unassigned_geography',
     backgroundColor = styleEqual(c(TRUE), c('lightpink') )
  ) %>%
  formatStyle(
    'unassigned_population',
     backgroundColor = styleEqual(c(TRUE), c('lightpink') )
  ) %>%
  formatStyle(
    'contiguity_mn',
     backgroundColor = styleEqual(c(1), c('lightgreen'),default='orange' )
  )
  
    
  })

#TODO: Set specified plan with row tab-selection -- complication is that table ID is autogenerated
#
# rmarkdown::render_delayed({  
#    renderPrint({
#     tn <- names(input)
#     ts<- tn[which(str_detect(tn,"rows_selected"))]
#     paste(ts,input)
#    })
#  })

```

# Details

```{r, drill-down-tabbed}

planlist <- contestPlans.tb$id ; names(planlist)<-contestPlans.tb$plan_name

## TODO: add db open buttons
# rmarkdown::render_delayed({  
#   renderTable({
#     curPlan() %>% rename("Districtbuilder"=dbView,"Planscore"=psView) %>% select(Districtbuilder,Planscore) 
#   }, sanitize.text.function = function(x) x)
# })

shinyApp(
  ui <- fluidPage(
    
    # App title ----
    #titlePanel("District Details & Comparison"),
    
    # Sidebar layout with input and output definitions ----
    sidebarLayout(
      
      # Sidebar panel for inputs ----
      sidebarPanel(
        selectInput("selected_plan", "Primary plan", planlist),
        selectInput("comparison_plan", "Comparison plan", planlist)
      ),
      
      # Main panel for displaying outputs ----
      mainPanel(
        
        # Output: Tabset w/ plot, summary, and table ----
        tabsetPanel(type = "tabs",
                    tabPanel("Plan Map", plotOutput("map")),
                    tabPanel("Plan Overview", tableOutput("overview")),
                    tabPanel("Plan Districts", DTOutput("details")),
                    tabPanel("Map Comparison",plotOutput("compareMap")),
                    tabPanel("Score Comparison", tableOutput("compareTable"))
        )
      )
    )
  ),
  server <- function(input, output) {
    
    # Reactive expressions
    curPlan <- reactive(contestPlans.tb %>% filter(id==input$selected_plan))
    curMap <-  reactive(curPlan()[[1,"map"]][[1]])
    compPlan <- reactive({contestPlans.tb %>% filter(id==input$comparison_plan)})
    compMap <-  reactive(compPlan()[[1,"map"]][[1]])
    
    
    #TODO: error presentation is a hack -- should figure out how to change output type...
    curPS <-   reactive({
      out <- curPlan()[[1,"districtScoreTable"]][[1]]
      if (is.null(out)) {out = tibble(warning="SCORES MISSING (Plan may be incomplete or corrupt)")}
      out
    }) 
    
    output$map <- renderPlot({
      curMap() %>% ggplot() + geom_sf()
    })
    
    output$overview <- renderTable({
      curPlan() %>% select(plan_name,plan_creator,description) 
    })
    
    output$details <- renderDT({
      curPS()
    })
    
    output$compareMap <- ({
      renderPlot({
        curMap() %>% 
          ggplot(aes(color= curPlan()$plan_name )) +
          geom_sf()+
          geom_sf(data=compMap(),aes(color=compPlan()$plan_name,alpha=0)) +
          guides(alpha="none") + labs(color="Plan")
      })
    })
    
    output$compareTable <- ({
      presTB <- reactive({
        compTb <- bind_rows(curPlan(),compPlan())  %>% select(where(is.numeric))
        pdiff<-  apply(compTb,2,function(x)(x[1]-x[2]))  
        tmpo <- bind_rows(compTb,pdiff)
        pname <- c(curPlan()$plan_name,compPlan()$plan_name,"Difference")
        tmpo <- bind_cols(planname=pname,tmpo)
        tmpo
      })
      
      renderTable({
        presTB()  %>%
          rownames_to_column() %>%  
          mutate(across(everything(),as.character)) %>%
          pivot_longer(-rowname) %>% 
          pivot_wider(names_from=rowname, values_from=value) 
      })
      
    })
    
  }
)

```
